# reconcile.py (The Final, Intelligent Version)

from pathlib import Path
import re

def get_package_name_from_line(line):
    """Robustly gets the package name from a requirements line."""
    # This handles extras like 'coverage[toml]'
    match = re.match(r'^[a-zA-Z0-9\-_\[\]\.]+', line)
    return match.group(0) if match else None

def is_line_strictly_pinned(line):
    """Checks if a line is a strict '==' pin."""
    # Using a regex is more robust than a simple '==' check.
    return bool(re.match(r'^[a-zA-Z0-9\-_\[\]\.]+==.+$', line))

def reconcile_requirements():
    """
    Intelligently reconciles the Golden Record (requirements.txt) with the
    Ideal State (temp-ideal-state.txt) generated from pyproject.toml.
    """
    golden_record_path = Path("requirements.txt")
    ideal_state_path = Path("temp-ideal-state.txt")

    if not ideal_state_path.exists():
        print("Ideal state file not found. Nothing to reconcile.")
        return

    # Read the ideal state generated by pip-compile
    with open(ideal_state_path, "r") as f:
        # We store the full lines to preserve version info
        ideal_deps_lines = {line.strip() for line in f if line.strip() and not line.strip().startswith('#') and not line.startswith('-e')}

    # If the Golden Record doesn't exist, create it based on the new logic.
    if not golden_record_path.exists() or golden_record_path.stat().st_size == 0:
        print("Golden Record not found. Creating a new requirements.txt...")
        new_lines = []
        for line in sorted(list(ideal_deps_lines)):
            if is_line_strictly_pinned(line):
                new_lines.append(line) # Keep the strict pin
            else:
                new_lines.append(get_package_name_from_line(line)) # Add unpinned
        
        with open(golden_record_path, "w") as f:
            f.write("\n".join(new_lines))
        print("New requirements.txt created. Bootstrap will be required.")
        return

    # --- Your Core Logic: The Intelligent Comparison ---
    with open(golden_record_path, "r") as f:
        golden_deps_lines = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]
    
    golden_package_names = {get_package_name_from_line(line) for line in golden_deps_lines}

    new_deps_to_add = []
    for ideal_line in ideal_deps_lines:
        ideal_pkg_name = get_package_name_from_line(ideal_line)
        if ideal_pkg_name not in golden_package_names:
            if is_line_strictly_pinned(ideal_line):
                # Case A: pyproject.toml had a strict pin, so we add it as-is.
                print(f"New strictly pinned dependency '{ideal_line}' discovered. Adding to requirements.txt.")
                new_deps_to_add.append(ideal_line)
            else:
                # Case B: pyproject.toml had a loose constraint. Add unpinned to trigger bootstrap.
                print(f"New loosely constrained dependency '{ideal_pkg_name}' discovered. Adding unpinned to requirements.txt.")
                new_deps_to_add.append(ideal_pkg_name)

    if new_deps_to_add:
        print(f"Adding {len(new_deps_to_add)} new dependencies to Golden Record.")
        with open(golden_record_path, "a") as f:
            f.write("\n")
            f.write("\n".join(sorted(new_deps_to_add)))
    else:
        print("Golden Record is already in sync with pyproject.toml. No new dependencies found.")

if __name__ == "__main__":
    reconcile_requirements()